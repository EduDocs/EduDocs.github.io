{"name":"EduDocs","tagline":"Educational Documents","body":"# The Snowball Effect\r\n\r\nThe constraints of higher education are such that instructors have limited time to plan courses and reflect on curriculums.\r\nIndeed, almost every engineering faculty member will assert that they somehow manage, perhaps barely, to juggle an untenable work schedule.\r\nAn important question then is: How should an instructor best prepare for lectures?\r\nIdentifying prime learning objectives and the most efficient teaching methodologies always provides fertile grounds for passionate discussions and academic debates.\r\n\r\nA facet of the teacher dilemma that often receives less attention is the long-term impact of immediate preparation decisions.\r\nShould an instructor focus exclusively on his or her next set of interactions with students, or should there be a tradeoff between an upcoming lecture and the long-term quality of a program?\r\nIt may be argued that a myopic view of teaching can lead to repetitive behaviors, duplicated efforts and thereby prevent instructors from realizing their true academic potential.\r\nA conscious decision to dedicate time to building lasting tools to subsequently enhance the productivity of an instructor, on the other hand, can elevate the quality of a program over time and hence benefit generations of students.\r\nThis philosophical approach applies to instructors, students and institutions alike.\r\nFor instance, out of a teaching workforce, what percentage of the faculty should be dedicated to building tools that support and boost the efforts of everyone else?\r\n\r\nThe perennial example of investing in the quality of education for future students is the authoring of books.\r\nThis represents a cherished tradition with a stupendous impact worldwide.\r\nStill, engineering books are often the fruits of long and laborious undertakings by dedicated authors.\r\nFurthermore, they often become term projects with no provision for evolution and continuity in the long run.\r\nThe present initiative looks at alternative means of creating pedagogical value out of everyday lesson planning and typical preparation times.\r\nIt discusses collaborative strategies and technologies that can help improve engineering education through incremental, concerted steps.\r\n\r\n\r\n## Collaborative Authorship\r\n\r\nComputer programmers and software engineers have developed a number of packages for source and revision control.\r\nAlthough originally aimed at the creation of large software applications, these accessible tools can be employed to generate a plethora of educational documents, from curriculums to notes and questions.\r\nDissociating content from presentation seems key in having contributors focus on enhancing pedagogical materials.\r\nAt this point, it may be useful to differentiate the aforementioned tools from wikis and content management systems, which are themselves becoming increasingly popular.\r\nBy nature, wikis typically lead to mosaics of information snippets; whereas versioning systems, although technologically more involved, are proper vehicles for concerted efforts with established goals.\r\nIn other words, the former favors concurrent, yet compartmentalized authorship; whereas the latter enables true collaborative authorship.\r\n\r\nA prime example of a software versioning and revision control system is [Git](http://git-scm.com/), which is a distributed version control system designed.\r\nThis software platform is free and open source, and it features a rich community of users and contributors.\r\nMoreover, [GitHub](https://github.com/) is a web-based hosting service for source code management.\r\nIt is built on the Git revision control system and offers free accounts for open source projects.\r\nIt offers a rich set of features, yet simplicity is one of its main attributes.\r\nAuthors and software developers regularly employ Git to maintain current and historical versions of files such as source code, web pages, and documentation.\r\nSome of our course notes are actively being developed as collaborative project under Git and GitHub.\r\n\r\nA powerful aspect of version control is that it enables multiple contributors to work on various parts of a project simultaneously, even in a geographically distributed setting.\r\nGit keeps track of modifications and allows for the (mostly) seamless integration of valuable work.\r\nFrom a user perspective and after initialization, the basic work cycle under Git amount to the following steps.\r\n\r\n* **Clone:** Use <clone> to instantiate a working copy of the master repository.\r\nThis is usually the first command employed to establish a local working hierarchy under this paradigm.\r\n* **Fetch:**\r\nThe <fetch> command imports changes on the remote server to the local working repository.\r\nBefore editing a project, it is typically advisable to synchronize the working copy with the latest version of the file hierarchy available on the server.\r\n* **Edit** source files:\r\nThis is perhaps the most natural part of the cycle.\r\nModify files, documents and folder as need, irrespective of the collaborative infrastructure.\r\n* **Review** changes:\r\nBefore sharing documents, one can quickly view a summary of the changes that were made through <diff>.\r\n* **Fix** mistakes:\r\nThis is a good time to fix typos and mistakes.\r\nSometimes, when things go wrong, the simplest option is to revert back to older versions of the files.\r\nThis is easy to do through Git.\r\n* **Resolve** conflicts:\r\nIn some cases, someone else may have been working on the same project at the same time.\r\nAs such, it is always safe to check if a new version of the project has been published on the server before committing your own work.\r\nGit offers several tools to identify potential editing conflicts and resolved such issues.\r\n* **Pull:**\r\nThe <pull> command fetches and merges changes on the remote server to the local working repository.\r\nBefore editing a project, it is typically advisable to synchronize the working copy with the latest version of the file hierarchy available on the server.\r\n* **Add:**\r\nThe add command is used to add one or more files to staging.\r\nOnly add pertinent files to the repository.\r\n* **Commit** changes:\r\n* **Push:**\r\nThe last step of the cycle is to publish your work on GitHub and share the latest version with collaborators.\r\nYour changes will be integrated in the master repository and others can now see your contribution.\r\n\r\nUnder GitHub, the Git editing cycle is actually very accessible.\r\nThis requires an eventual contributor to learn the technology, yet the rewards are many.\r\nIn particular, this is one possible way to improve educational documents through incremental, concerted steps.\r\n\r\n\r\n## The Alignment of Deliverables and Valuables\r\n\r\nUndergraduate students in engineering programs have to complete a capstone project as part of their education, due partly to the guidelines of the Accreditation Board for Engineering and Technology.\r\nMany schools ask for a comprehensive report to fulfill the writing requirements of the course.\r\nTo bring up the quality of the projects, it may be possible to modify course requirements slightly and have students produce tutorials about the different technologies they are using.\r\nThe latter documents typically have much broader appeal and they can be used to bootstrap the projects of subsequent generations of students.\r\nTutorials still serve the original purpose of being a comprehensive writing exercise, yet they concomitantly raise the quality of the projects over time by contributing to the capstone culture.\r\n\r\n","google":"UA-7761657-3","note":"Don't delete this file! It's used internally to help with page regeneration."}